package com.zutubi.pulse.master.database;

import com.zutubi.pulse.master.bootstrap.MasterConfigurationManager;
import com.zutubi.pulse.master.util.jdbc.DriverWrapper;
import com.zutubi.util.FileSystemUtils;
import com.zutubi.util.RandomUtils;
import com.zutubi.util.io.IOUtils;
import com.zutubi.util.logging.Logger;

import java.io.File;
import java.io.IOException;
import java.net.URL;
import java.net.URLClassLoader;
import java.sql.Driver;
import java.sql.DriverManager;
import java.util.Enumeration;
import java.util.Properties;

/**
 *
 *
 */
public class DriverRegistry
{
    private static final String PROPERTIES_FILE_COMMENT = "Generated by Pulse";

    private static final Logger LOG = Logger.getLogger(DriverRegistry.class);

    private File driverDir;

    public void init()
    {
        try
        {
            ensureDriverDirectoryInitialised();

            // read the registered files.
            File registry = getRegistryFile();

            Properties registeredDrivers = IOUtils.read(registry);
            Enumeration e = registeredDrivers.keys();
            while (e.hasMoreElements())
            {
                String driverClassName = (String) e.nextElement();
                String jarFileName = registeredDrivers.getProperty(driverClassName);

                try
                {
                    loadDriver(driverClassName, jarFileName);
                }
                catch (IOException e1)
                {
                    LOG.warning("Failed to load jdbc driver " + driverClassName + ".");
                }
            }
        }
        catch (IOException e1)
        {
            LOG.warning("Failed to load jdbc drivers.  Unable to read registry file. ");
        }
    }

    public void unregisterOnRestart(String driverClassName) throws IOException
    {
        File registryFile = getRegistryFile();
        Properties registeredDrivers = IOUtils.read(registryFile);

        if (registeredDrivers.containsKey(driverClassName))
        {
            registeredDrivers.remove(driverClassName);
            IOUtils.write(registeredDrivers, registryFile, PROPERTIES_FILE_COMMENT);
        }
    }

    public void register(String driverClassName) throws IOException
    {
        register(driverClassName, null);
    }

    public void register(String driverClassName, File jar) throws IOException
    {
        ensureDriverDirectoryInitialised();

        if (isRegistered(driverClassName))
        {
            return;
        }

        if (jar != null)
        {
            if (!FileSystemUtils.isParentOf(driverDir, jar))
            {
                String uniqueFilename = jar.getName() + RandomUtils.randomString(5);

                FileSystemUtils.copy(driverDir, jar);
                FileSystemUtils.robustRename(new File(driverDir, jar.getName()), new File(driverDir, uniqueFilename));
                jar = new File(driverDir, uniqueFilename);
            }
            // else do not want to try to copy a file into directory if it is already there.
        }

        // load the driver.
        if (jar != null)
        {
            loadDriver(driverClassName, jar.getName());
        }
        else
        {
            loadDriver(driverClassName);
        }

        // record new driver.
        File registryFile = getRegistryFile();
        Properties registeredDrivers = IOUtils.read(registryFile);
        registeredDrivers.setProperty(driverClassName, (jar != null) ? jar.getName() : "");
        IOUtils.write(registeredDrivers, registryFile, PROPERTIES_FILE_COMMENT);
    }

    public boolean isRegistered(String className)
    {
        // can check the registry file or the DriverManager.
//        isRegisteredWithRegistryFile(className);
        return isRegisteredWithDriverManager(className);
    }

    private boolean isRegisteredWithRegistryFile(String className)
    {
        File registryFile = getRegistryFile();
        if (registryFile.isFile())
        {
            try
            {
                Properties registeredDrivers = IOUtils.read(registryFile);
                return registeredDrivers.containsKey(className);
            }
            catch (IOException e)
            {
                return false;
            }
        }
        return false;
    }

    private boolean isRegisteredWithDriverManager(String className)
    {
        Enumeration<Driver> drivers = DriverManager.getDrivers();
        while (drivers.hasMoreElements())
        {
            Driver driver = drivers.nextElement();
            if (driver instanceof DriverWrapper)
            {
                driver = ((DriverWrapper)driver).getDelegate();
            }

            if (driver.getClass().getName().equals(className))
            {
                return true;
            }
        }
        return false;
    }

    private void ensureDriverDirectoryInitialised() throws IOException
    {
        if (!driverDir.isDirectory() && !driverDir.mkdirs())
        {
            throw new IOException("Failed to create " + driverDir.getCanonicalPath());
        }

        File registryFile = getRegistryFile();
        if (!registryFile.isFile() && !registryFile.createNewFile())
        {
            throw new IOException("Failed to create " + registryFile.getCanonicalPath());
        }
    }

    private File getRegistryFile()
    {
        return new File(driverDir, ".registry");
    }

    private void loadDriver(String driverClassName) throws IOException
    {
        loadDriver(driverClassName, null);
    }

    private void loadDriver(String driverClassName, String jarFileName) throws IOException
    {
        try
        {
            Class driverClass = null;

            // look at the jar file first.
            if (jarFileName != null && jarFileName.length() > 0)
            {
                
                //TODO: if we load the classfile from the jar, then a file handle remains open on that jar
                //TODO: until the jvm shuts down. (or at least this appears to be the case).  Is there anyway
                //TODO: around this, to cleanup this open file handle?

                File jar = new File(driverDir, jarFileName);
                URLClassLoader loader = new URLClassLoader(new URL[]{jar.toURI().toURL()});
                driverClass = loader.loadClass(driverClassName);
            }

            // next look on the base classpath.
            if (driverClass == null)
            {
                driverClass = Class.forName(driverClassName);
            }

            Driver driver = new DriverWrapper((Driver) driverClass.newInstance());
            DriverManager.registerDriver(driver);
        }
        catch (Exception e)
        {
            throw new IOException("Unable to load database driver: " + e.getMessage());
        }
    }

    public void setConfigurationManager(MasterConfigurationManager configurationManager)
    {
        setDriverDir(configurationManager.getData().getDriverRoot());
    }

    public void setDriverDir(File driverDir)
    {
        this.driverDir = driverDir;
    }
}
