package com.zutubi.pulse.master.events.build;

import com.zutubi.pulse.core.BuildRevision;
import com.zutubi.pulse.core.engine.api.ResultState;
import com.zutubi.pulse.core.model.NamedEntity;
import com.zutubi.pulse.master.model.*;
import com.zutubi.pulse.master.tove.config.project.ProjectConfiguration;
import com.zutubi.pulse.master.tove.config.project.DependencyConfiguration;
import com.zutubi.pulse.master.DependencyRebuildScheduleHandler;
import com.zutubi.util.CollectionUtils;

import java.util.Map;
import java.util.List;

/**
 * A build request event that is used when multiple dependent projects
 * are being 'rebuilt'.
 *
 * @see com.zutubi.pulse.master.DependencyRebuildScheduleHandler
 */
public class RebuildRequestEvent extends BuildRequestEvent
{
    private Project owner;
    private final Map<ProjectConfiguration, BuildResult> resultCache;
    private ProjectConfiguration rootProject;
    private DependencyRebuildScheduleHandler source;

    public RebuildRequestEvent(DependencyRebuildScheduleHandler source, BuildRevision revision, Project project, TriggerOptions options, ProjectConfiguration rootProject, Map<ProjectConfiguration, BuildResult> resultCache)
    {
        super(source, revision, project.getConfig(), options);
        this.source = source;
        this.owner = project;
        this.resultCache = resultCache;
        this.rootProject = rootProject;
    }

    public NamedEntity getOwner()
    {
        return this.owner;
    }

    public boolean isPersonal()
    {
        return false;
    }

    public String getStatus()
    {
        String status = getProjectConfig().getDependencies().getStatus();
        if (getOptions().hasStatus())
        {
            status = options.getStatus();
        }
        return status;
    }

    public BuildResult createResult(ProjectManager projectManager, BuildManager buildManager)
    {
        // The result cache is a map shared between the multiple rebuild request event instances
        // that are generated by the single DependencyRebuildScheduleHandler.  
        synchronized (resultCache)
        {
            if (!resultCache.containsKey(getProjectConfig()))
            {
                prepareResults(rootProject, resultCache, buildManager, projectManager);
            }
            BuildResult result = resultCache.get(getProjectConfig());
            result.setState(ResultState.PENDING);
            buildManager.save(result);

            return result;
        }
    }

    private BuildResult prepareResults(ProjectConfiguration project, Map<ProjectConfiguration, BuildResult> preparedResults, BuildManager buildManager, ProjectManager projectManager)
    {
        BuildResult result = newBuildResult(project, projectManager);
        preparedResults.put(project, result);

        List<DependencyConfiguration> traversableDependencies = CollectionUtils.filter(
                project.getDependencies().getDependencies(),
                source.getTraverseDependencyPredicate()
        );

        for (DependencyConfiguration dependency : traversableDependencies)
        {
            ProjectConfiguration p = dependency.getProject();

            BuildResult dependentResult = prepareResults(p, preparedResults, buildManager, projectManager);
            result.addDependsOn(dependentResult);
        }

        buildManager.save(result);
        return result;
    }

    private BuildResult newBuildResult(ProjectConfiguration projectConfig, ProjectManager projectManager)
    {
        Project project = projectManager.getProject(projectConfig.getProjectId(), false);
        BuildResult result = new BuildResult(options.getReason(), project, projectManager.getNextBuildNumber(project, true), getRevision().isUser());

        result.setStatus(getStatus());
        result.setBuildId(getBuildId());
        result.setState(ResultState.PENDING_DEPENDENCY);
        
        return result;
    }
}
