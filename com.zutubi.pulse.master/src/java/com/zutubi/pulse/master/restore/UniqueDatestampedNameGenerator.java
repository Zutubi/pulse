/* Copyright 2017 Zutubi Pty Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.zutubi.pulse.master.restore;

import java.io.File;
import java.io.FilenameFilter;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.Date;

/**
 * An implementation of the name generator that uses a date stamp to
 * uniquely name the archive file.
 */
public class UniqueDatestampedNameGenerator implements ArchiveNameGenerator
{
    private Clock time = new CalendarClock();

    static SimpleDateFormat getDateFormat()
    {
        return new SimpleDateFormat("yyyy-MM-dd_hh-mm-ss");
    }

    /**
     * Generate a unique filename for an archive file that will be placed into the target directory.
     *
     * @param target directory into which the archive file will be placed.
     * @return the generated file name.
     */
    public String newName(File target)
    {
        final String candidateName = "archive-" + getDateFormat().format(time.getDate());

        //TODO: check latest file name, and use that as a starting point for the 'i'
        String[] names = new String[0];
        if (target.isDirectory())
        {
            names = target.list(new FilenameFilter()
            {
                public boolean accept(File dir, String name)
                {
                    return name.startsWith(candidateName);
                }
            });
        }

        int i = 0;
        for (String name : names)
        {
            String postfix = name.substring(27, name.length() - 4);
            if (postfix.startsWith("_"))
            {
                postfix = postfix.substring(1);
                if (Integer.valueOf(postfix) > i)
                {
                    i = Integer.valueOf(postfix);
                }
            }
        }

        File candidate;
        if (i > 0)
        {
            candidate = new File(target, candidateName + "_" + i + ".zip");
        }
        else
        {
            candidate = new File(target, candidateName + ".zip");
        }

        i = i + 1;
        while (candidate.isFile())
        {
            candidate = new File(target, candidateName + "_" + i + ".zip");
            i++;
        }
        return candidate.getName();
    }

    /**
     * Returns true if the specified name matches the format of the names generated
     * by this name generator.
     *
     * @param name the name to be checked.
     * @return true if the name could have been generated by this generator, false otherwise.
     */
    public boolean matches(String name)
    {
        if (!name.startsWith("archive-"))
        {
            return false;
        }
        if (!name.endsWith(".zip"))
        {
            return false;
        }
        name = name.substring(8, name.length() - 4);
        try
        {
            // date format appears to be rather liberal, it is happy to accept and correctly parse
            // dates of the format:  yyyy-MM-dd_hh-mm-ss_<someExtraNumber> as yyyy-MM-dd_hh-mm-ss. 
            getDateFormat().parse(name);
            return true;
        }
        catch (ParseException e)
        {
            return false;
        }
    }

    public void setTime(Clock time)
    {
        this.time = time;
    }

    protected interface Clock
    {
        Date getDate();
    }

    protected class CalendarClock implements Clock
    {
        public Date getDate()
        {
            return Calendar.getInstance().getTime();
        }
    }
}
