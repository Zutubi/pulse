package com.zutubi.pulse.core.dependency.ivy;

import static com.zutubi.pulse.core.util.api.XMLStreamUtils.*;
import com.zutubi.util.CollectionUtils;
import com.zutubi.util.Predicate;
import com.zutubi.util.io.IOUtils;
import com.zutubi.util.logging.Logger;
import org.apache.ivy.core.cache.ArtifactOrigin;
import org.apache.ivy.core.module.descriptor.Artifact;
import org.apache.ivy.core.module.descriptor.DefaultArtifact;
import org.apache.ivy.core.module.id.ModuleRevisionId;
import org.apache.ivy.core.report.ArtifactDownloadReport;
import org.apache.ivy.core.report.DownloadStatus;
import org.apache.ivy.plugins.report.XmlReportParser;
import org.xml.sax.SAXException;
import org.xml.sax.helpers.AttributesImpl;

import javax.xml.stream.XMLInputFactory;
import javax.xml.stream.XMLStreamConstants;
import javax.xml.stream.XMLStreamException;
import javax.xml.stream.XMLStreamReader;
import javax.xml.transform.OutputKeys;
import javax.xml.transform.TransformerConfigurationException;
import javax.xml.transform.sax.SAXTransformerFactory;
import javax.xml.transform.sax.TransformerHandler;
import javax.xml.transform.stream.StreamResult;
import java.io.*;
import java.text.ParseException;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;

/**
 * The retrieval report is generated by the ivy retrieval process, and
 * lists the artifacts that were retrieved to the local file system.
 *
 * This report can be persisted to xml format.
 */
public class IvyRetrievalReport
{
    private static final Logger LOG = Logger.getLogger(IvyRetrievalReport.class);

    private static final String ELEMENT_ARTIFACT = "artifact";
    private static final String ELEMENT_EXTRA_ATTRIBUTE = "extra";
    private static final String ELEMENT_MODULE = "module";
    private static final String ELEMENT_MODULES = "modules";

    private static final String ATTRIBUTE_ORGANISATION = "organisation";
    private static final String ATTRIBUTE_MODULE = "name";
    private static final String ATTRIBUTE_REVISION = "revision";
    private static final String ATTRIBUTE_EXTENSION = "ext";
    private static final String ATTRIBUTE_TYPE = "type";
    private static final String ATTRIBUTE_NAME = "name";

    private static final String XML_CDATA = "CDATA";

    private Map<ModuleRevisionId, List<ArtifactDownloadReport>> moduleArtifacts = new HashMap<ModuleRevisionId, List<ArtifactDownloadReport>>();
    private static final String ELEMENT_DOWNLOAD_REPORT = "downloadReport";
    private static final String ATTRIBUTE_STATUS = "status";
    private static final String ATTRIBUTE_DETAILS = "details";
    private static final String ATTRIBUTE_TIME = "time";
    private static final String ATTRIBUTE_SIZE = "size";
    private static final String ATTRIBUTE_LOCATION = "location";
    private static final String ATTRIBUTE_LOCAL = "local";
    private static final String ELEMENT_ARTIFACT_ORIGIN = "origin";

    /**
     * Read a retrieval report from the specified file.
     *
     * @param file  the file containing the xml formatted report.
     *
     * @return  an instance of the report representing the data contained within the file.
     *
     * @throws ParseException           is thrown if there is a problem parsing the file.
     * @throws FileNotFoundException    is thrown if the file could not be located
     * @throws XMLStreamException       is thrown if there is a problem parsing the file
     */
    public static IvyRetrievalReport fromXml(File file) throws ParseException, FileNotFoundException, XMLStreamException
    {
        FileInputStream input = null;
        try
        {
            input = new FileInputStream(file);
            return fromXml(input);
        }
        catch (Exception e)
        {
            // The file format is not what we expected, revert to the older format for backward compatibility.
            LOG.warning("Failed to parse ivy retrieval report. Cause: " + e.getClass() + " " + e.getMessage() +
                    ". Reverting to resolution report format.");
        }
        finally
        {
            IOUtils.close(input);
        }

        XmlReportParser parser = new XmlReportParser();
        parser.parse(file);

        return fromXml(parser);
    }

    /**
     * Read a retrieval report from the xml report parser.
     *
     * @param parser    report parser containing the retriveal details the
     * retrieval report is to be based on.
     *
     * @return an instance of the report representing the data in the report parser.
     */
    public static IvyRetrievalReport fromXml(XmlReportParser parser)
    {
        IvyRetrievalReport report = new IvyRetrievalReport();

        for (ArtifactDownloadReport downloadReport : parser.getArtifactReports())
        {
            report.addDownloadReports(downloadReport);
        }

        return report;
    }

    /**
     * Read a retrieval report from the input stream.
     *
     * @param input the input stream containing the serialised contents of
     * an ivy retrieval report.
     * @return an instance of the retrieval report representing the contents of the
     * input stream.
     *
     * @throws XMLStreamException on error
     *
     * @see #toXml(java.io.OutputStream) 
     */
    public static IvyRetrievalReport fromXml(InputStream input) throws XMLStreamException
    {
        XMLStreamReader reader = null;
        try
        {
            XMLInputFactory inputFactory = XMLInputFactory.newInstance();
            reader = inputFactory.createXMLStreamReader(input);

            // scroll forward past the header to the first element
            while (reader.getEventType() != XMLStreamConstants.END_DOCUMENT && !reader.isStartElement())
            {
                reader.next();
            }

            IvyRetrievalReport report = new IvyRetrievalReport();

            if (reader.isStartElement())
            {
                readModules(reader, report);
            }
            return report;
        }
        finally
        {
            close(reader);
        }
    }

    private static void readModules(XMLStreamReader reader, IvyRetrievalReport report) throws XMLStreamException
    {
        expectStartTag(ELEMENT_MODULES, reader);
        reader.nextTag();

        while (nextSiblingTag(reader, ELEMENT_MODULE))
        {
            Map<String, String> attributes = getAttributes(reader);
            ModuleRevisionId mrid = ModuleRevisionId.newInstance(
                    attributes.get(ATTRIBUTE_ORGANISATION),
                    attributes.get(ATTRIBUTE_MODULE),
                    attributes.get(ATTRIBUTE_REVISION));

            reader.nextTag();

            while (nextSiblingTag(reader, ELEMENT_DOWNLOAD_REPORT))
            {
                readDownloadReport(reader, mrid, report);
            }
            expectEndTag(ELEMENT_MODULE, reader);
            reader.nextTag();
        }

        expectEndTag(ELEMENT_MODULES, reader);
    }

    private static void readDownloadReport(XMLStreamReader reader, ModuleRevisionId mrid, IvyRetrievalReport report) throws XMLStreamException
    {
        expectStartTag(ELEMENT_DOWNLOAD_REPORT, reader);

        Map<String, String> attributes = getAttributes(reader);

        String status = attributes.get(ATTRIBUTE_STATUS);
        String details = attributes.get(ATTRIBUTE_DETAILS);
        String time = attributes.get(ATTRIBUTE_TIME);
        String size = attributes.get(ATTRIBUTE_SIZE);
        reader.nextTag();

        Artifact artifact = null;
        ArtifactOrigin origin = null;
        while (nextSiblingTag(reader, ELEMENT_ARTIFACT, ELEMENT_ARTIFACT_ORIGIN))
        {
            if (isElement(ELEMENT_ARTIFACT, reader))
            {
                artifact = readArtifact(reader, mrid);
            }
            else if (isElement(ELEMENT_ARTIFACT_ORIGIN, reader))
            {
                origin = readArtifactOrigin(reader, artifact);
            }
        }

        ArtifactDownloadReport downloadReport = new ArtifactDownloadReport(artifact);
        downloadReport.setArtifactOrigin(origin);
        downloadReport.setDownloadDetails(details);
        downloadReport.setSize(Long.valueOf(size));
        downloadReport.setDownloadTimeMillis(Long.valueOf(time));
        downloadReport.setDownloadStatus((status != null) ? DownloadStatus.fromString(status) : null);
        report.addDownloadReports(downloadReport);

        expectEndTag(ELEMENT_DOWNLOAD_REPORT, reader);
        reader.nextTag();
    }

    private static ArtifactOrigin readArtifactOrigin(XMLStreamReader reader, Artifact artifact) throws XMLStreamException
    {
        expectStartTag(ELEMENT_ARTIFACT_ORIGIN, reader);

        Map<String, String> attributes = getAttributes(reader);
        String location = attributes.get(ATTRIBUTE_LOCATION);
        String local = attributes.get(ATTRIBUTE_LOCAL);

        ArtifactOrigin origin = new ArtifactOrigin(artifact, Boolean.valueOf(local), location);
        reader.nextTag();

        expectEndTag(ELEMENT_ARTIFACT_ORIGIN, reader);
        reader.nextTag();
        return origin;
    }

    private static Artifact readArtifact(XMLStreamReader reader, ModuleRevisionId mrid) throws XMLStreamException
    {
        expectStartTag(ELEMENT_ARTIFACT, reader);

        Map<String, String> attributes = getAttributes(reader);

        String name = attributes.get(ATTRIBUTE_NAME);
        String type = attributes.get(ATTRIBUTE_TYPE);
        String extension = attributes.get(ATTRIBUTE_EXTENSION);
        reader.nextTag();

        Map<String, String> extraAttributes = null;

        if (reader.getLocalName().equals(ELEMENT_EXTRA_ATTRIBUTE))
        {
            reader.nextTag();

            extraAttributes = readElements(reader);

            expectEndTag(ELEMENT_EXTRA_ATTRIBUTE, reader);
            reader.nextTag();
        }

        DefaultArtifact artifact = new DefaultArtifact(mrid, null, name, type, extension, extraAttributes);

        expectEndTag(ELEMENT_ARTIFACT, reader);
        reader.nextTag();

        return artifact;
    }

    protected IvyRetrievalReport()
    {
    }

    /**
     * Write this report to the output stream in an xml format.
     *
     * @param output    the output stream to which this report is written.
     * @throws SAXException is thrown if there is a problem generating the xml output.
     */
    public void toXml(OutputStream output) throws TransformerConfigurationException, SAXException
    {
        TransformerHandler saxHandler = createTransformerHandler(output);
        saxHandler.startDocument();
        saxHandler.startElement(null, ELEMENT_MODULES, ELEMENT_MODULES, null);

        for (ModuleRevisionId mrid : moduleArtifacts.keySet())
        {
            AttributesImpl moduleAttrs = new AttributesImpl();
            moduleAttrs.addAttribute(null, ATTRIBUTE_ORGANISATION, ATTRIBUTE_ORGANISATION, XML_CDATA, mrid.getOrganisation());
            moduleAttrs.addAttribute(null, ATTRIBUTE_MODULE, ATTRIBUTE_MODULE, XML_CDATA, mrid.getName());
            moduleAttrs.addAttribute(null, ATTRIBUTE_REVISION, ATTRIBUTE_REVISION, XML_CDATA, mrid.getRevision());
            saxHandler.startElement(null, ELEMENT_MODULE, ELEMENT_MODULE, moduleAttrs);

            List<ArtifactDownloadReport> downloadReports = moduleArtifacts.get(mrid);
            for (ArtifactDownloadReport report : downloadReports)
            {
                AttributesImpl reportAttrs = new AttributesImpl();
                reportAttrs.addAttribute(null, ATTRIBUTE_STATUS, ATTRIBUTE_STATUS, XML_CDATA, report.getDownloadStatus().toString());
                reportAttrs.addAttribute(null, ATTRIBUTE_DETAILS, ATTRIBUTE_DETAILS, XML_CDATA, report.getDownloadDetails());
                reportAttrs.addAttribute(null, ATTRIBUTE_TIME, ATTRIBUTE_TIME, XML_CDATA, String.valueOf(report.getDownloadTimeMillis()));
                reportAttrs.addAttribute(null, ATTRIBUTE_SIZE, ATTRIBUTE_SIZE, XML_CDATA, String.valueOf(report.getSize()));
                saxHandler.startElement(null, ELEMENT_DOWNLOAD_REPORT, ELEMENT_DOWNLOAD_REPORT, reportAttrs);

                Artifact artifact = report.getArtifact();
                AttributesImpl artifactAttrs = new AttributesImpl();
                artifactAttrs.addAttribute(null, ATTRIBUTE_NAME, ATTRIBUTE_NAME, XML_CDATA, artifact.getName());
                artifactAttrs.addAttribute(null, ATTRIBUTE_EXTENSION, ATTRIBUTE_EXTENSION, XML_CDATA, artifact.getExt());
                artifactAttrs.addAttribute(null, ATTRIBUTE_TYPE, ATTRIBUTE_TYPE, XML_CDATA, artifact.getType());
                saxHandler.startElement(null, ELEMENT_ARTIFACT, ELEMENT_ARTIFACT, artifactAttrs);

                if (artifact.getExtraAttributes().size() > 0)
                {
                    saxHandler.startElement(null, ELEMENT_EXTRA_ATTRIBUTE, ELEMENT_EXTRA_ATTRIBUTE, null);

                    Map<String, String> extraAttributes = artifact.getExtraAttributes();
                    for (String key : extraAttributes.keySet())
                    {
                        char[] value = extraAttributes.get(key).toCharArray();
                        saxHandler.startElement(null, key, key, null);
                        saxHandler.startCDATA();
                        saxHandler.characters(value, 0, value.length);
                        saxHandler.endCDATA();
                        saxHandler.endElement(null, key, key);
                    }

                    saxHandler.endElement(null, ELEMENT_EXTRA_ATTRIBUTE, ELEMENT_EXTRA_ATTRIBUTE);
                }

                saxHandler.endElement(null, ELEMENT_ARTIFACT, ELEMENT_ARTIFACT);

                ArtifactOrigin origin = report.getArtifactOrigin();
                if (origin != null)
                {
                    AttributesImpl originAttrs = new AttributesImpl();
                    originAttrs.addAttribute(null, ATTRIBUTE_LOCATION, ATTRIBUTE_LOCATION, XML_CDATA, origin.getLocation());
                    originAttrs.addAttribute(null, ATTRIBUTE_LOCAL, ATTRIBUTE_LOCAL, XML_CDATA, String.valueOf(origin.isLocal()));
                    saxHandler.startElement(null, ELEMENT_ARTIFACT_ORIGIN, ELEMENT_ARTIFACT_ORIGIN, originAttrs);
                    saxHandler.endElement(null, ELEMENT_ARTIFACT_ORIGIN, ELEMENT_ARTIFACT_ORIGIN);
                }
                saxHandler.endElement(null, ELEMENT_DOWNLOAD_REPORT, ELEMENT_DOWNLOAD_REPORT);
            }

            saxHandler.endElement(null, ELEMENT_MODULE, ELEMENT_MODULE);
        }

        saxHandler.endElement(null, ELEMENT_MODULES, ELEMENT_MODULES);
        saxHandler.endDocument();
    }

    private TransformerHandler createTransformerHandler(OutputStream outputStream) throws SAXException
    {
        try
        {
            SAXTransformerFactory transformerFact = (SAXTransformerFactory) SAXTransformerFactory.newInstance();
            TransformerHandler saxHandler = transformerFact.newTransformerHandler();
            saxHandler.getTransformer().setOutputProperty(OutputKeys.ENCODING, "UTF-8");
            saxHandler.getTransformer().setOutputProperty(OutputKeys.INDENT, "yes");
            saxHandler.setResult(new StreamResult(outputStream));
            return saxHandler;
        }
        catch (TransformerConfigurationException e)
        {
            throw new SAXException(e);
        }
    }

    /**
     * Include the specified artifact download reports to this report.
     *
     * @param reports    the reports to be added.
     */
    protected void addDownloadReports(ArtifactDownloadReport... reports)
    {
        for (ArtifactDownloadReport report : reports)
        {
            Artifact artifact = report.getArtifact();
            ModuleRevisionId mrid = artifact.getModuleRevisionId();
            if (!moduleArtifacts.containsKey(mrid))
            {
                moduleArtifacts.put(mrid, new LinkedList<ArtifactDownloadReport>());
            }
            List<ArtifactDownloadReport> artifacts = moduleArtifacts.get(mrid);
            artifacts.add(report);
        }
    }

    /**
     * Get a list of all of the artifacts downloaded.
     *
     * @return a list of artifacts.
     */
    public List<Artifact> getDownloadedArtifacts()
    {
        List<Artifact> artifacts = new LinkedList<Artifact>();
        for (ModuleRevisionId mrid : moduleArtifacts.keySet())
        {
            artifacts.addAll(getDownloadedArtifacts(mrid));
        }
        return artifacts;
    }

    /**
     * Get a list of downloaded artifacts contained that belong to the specified module
     *
     * @param mrid  the module revision id specifying the subset of
     * artifacts to be returned.
     *
     * @return a list of artifacts.
     */
    public List<Artifact> getDownloadedArtifacts(ModuleRevisionId mrid)
    {
        List<Artifact> artifacts = new LinkedList<Artifact>();
        for (ArtifactDownloadReport report : moduleArtifacts.get(mrid))
        {
            if (report.isDownloaded())
            {
                artifacts.add(report.getArtifact());
            }
        }
        return artifacts;
    }

    /**
     * Returns true if one or more reports show a problem with the download of their
     * respective artifacts.
     *
     * @return true if a problem is present, false otherwise.
     */
    public boolean hasFailures()
    {
        return getFailures().size() > 0;
    }

    public List<ArtifactDownloadReport> getFailures()
    {
        List<ArtifactDownloadReport> failures = new LinkedList<ArtifactDownloadReport>();
        for (ModuleRevisionId mrid : moduleArtifacts.keySet())
        {
            failures.addAll(CollectionUtils.filter(moduleArtifacts.get(mrid), new Predicate<ArtifactDownloadReport>()
            {
                public boolean satisfied(ArtifactDownloadReport downloadReport)
                {
                    return downloadReport.getDownloadStatus() == DownloadStatus.FAILED;
                }
            }));
        }
        return failures;
    }
}
