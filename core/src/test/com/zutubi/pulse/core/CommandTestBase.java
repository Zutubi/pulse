package com.zutubi.pulse.core;

import com.zutubi.pulse.BuildContext;
import com.zutubi.pulse.core.model.*;
import com.zutubi.pulse.events.DefaultEventManager;
import com.zutubi.pulse.events.Event;
import com.zutubi.pulse.events.EventListener;
import com.zutubi.pulse.events.EventManager;
import com.zutubi.pulse.events.build.*;
import com.zutubi.pulse.test.PulseTestCase;
import com.zutubi.pulse.util.FileSystemUtils;
import com.zutubi.pulse.util.IOUtils;

import java.io.*;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.TimeUnit;

/**
 * <class-comment/>
 */
public abstract class CommandTestBase extends PulseTestCase implements EventListener
{
    protected File baseDir;
    protected File outputDir;

    protected EventManager eventManager;
    protected LinkedBlockingQueue<Event> events;

    public CommandTestBase()
    {
    }

    public CommandTestBase(String name)
    {
        super(name);
    }

    public void setUp() throws IOException
    {
        baseDir = FileSystemUtils.createTempDir(getClass().getName(), ".base");
        outputDir = FileSystemUtils.createTempDir(getClass().getName(), ".out");

        eventManager = new DefaultEventManager();
        events = new LinkedBlockingQueue<Event>(10);
        eventManager.register(this);
    }

    public void tearDown() throws IOException
    {
        events = null;
        eventManager = null;
        removeDirectory(baseDir);
        removeDirectory(outputDir);
    }

    protected CommandResult failedRun(Command command, String ...contents) throws Exception
    {
        CommandResult commandResult = runCommand(command);
        assertEquals(ResultState.FAILURE, commandResult.getState());
        checkOutput(commandResult, contents);
        return commandResult;
    }

    protected CommandResult successRun(Command command, String ...contents) throws Exception
    {
        CommandResult commandResult = runCommand(command);
        assertEquals(ResultState.SUCCESS, commandResult.getState());
        checkOutput(commandResult, contents);
        return commandResult;
    }

    protected CommandResult runCommand(Command command) throws Exception
    {
        return runCommand(command, null);
    }

    /**
     * Simple framework for method for running a command within the context of a recipe.
     *
     * @param command to be executed.
     * @param buildContext for the commands execution, if one exists.
     * @return the command result instance generated by the execution of this command.
     */
    protected CommandResult runCommand(Command command, BuildContext buildContext)
    {
        RecipeContext recipeContext = new RecipeContext();
        recipeContext.setBuildContext(buildContext);
        recipeContext.setRecipePaths(new SimpleRecipePaths(baseDir, outputDir));

        Recipe recipe = new Recipe();
        recipe.setEventManager(eventManager);
        recipe.add(command);

        // need to add the build number to the global scope in the same way that the recipe processor does.
        if (buildContext != null && buildContext.getBuildNumber() > 0)
        {
            Scope scope = new Scope();
            scope.add(new Property("build.number", Long.toString(buildContext.getBuildNumber())));
            recipeContext.setGlobalScope(scope);
        }

        recipe.execute(recipeContext);

        assertCommandCommenced(command.getName());
        CommandCompletedEvent event = assertCommandCompleted(command.getName());

        return event.getResult();
    }

    /**
     * Verify that the output associated with the command result contains the specified contents.
     *
     * @param commandResult being checked.
     * @param contents that much exist in the command results output.
     *
     * @throws IOException if there is a problem extracting the output contents.
     */
    protected void checkOutput(CommandResult commandResult, String ...contents) throws IOException
    {
        File outputFile = getCommandOutput(commandResult);
        checkContents(outputFile, contents);
    }

    protected void checkEnv(CommandResult commandResult, String ...contents) throws IOException
    {
        File outputFile =  getCommandEnv(commandResult);
        checkContents(outputFile, false, contents);
    }

    protected void checkContents(File outputFile, String... contents) throws IOException
    {
        checkContents(outputFile, true, contents);
    }

    protected void checkArtifact(CommandResult result, StoredArtifact artifact, String... contents) throws IOException
    {
        assertNotNull(artifact);
        File expectedFile = getCommandArtifact(result, artifact);
        checkContents(expectedFile, true, contents);
    }

    protected void checkContents(File outputFile, boolean caseSensitive, String... contents) throws IOException
    {
        FileInputStream is = null;
        try
        {
            is = new FileInputStream(outputFile);
            String output = IOUtils.inputStreamToString(is);
            assertOutputContains(output, caseSensitive, contents);
        }
        finally
        {
            IOUtils.close(is);
        }
    }

    /**
     * The default build filename.
     *
     */
    protected abstract String getBuildFileName();

    /**
     * The template build file extension.
     *
     */
    protected abstract String getBuildFileExt();

    protected void copyBuildFileToBaseDir(String name) throws IOException
    {
        copyBuildFile(name, getBuildFileName());
    }

    protected void copyBuildFile(String name, String filename) throws IOException
    {
        InputStream is = null;
        OutputStream os = null;
        try
        {
            is = getInput(name, getBuildFileExt());
            os = new FileOutputStream(new File(baseDir, filename));
            IOUtils.joinStreams(is, os);
        }
        finally
        {
            IOUtils.close(is);
            IOUtils.close(os);
        }
    }

    protected void assertOutputContains(String output, String... contents)
    {
        assertOutputContains(output, true, contents);
    }

    protected void assertOutputContains(String output, boolean caseSensitive, String... contents)
    {
        if (!caseSensitive)
        {
            output = output.toLowerCase();
        }
        for (String content : contents)
        {
            if (!caseSensitive)
            {
                content = content.toLowerCase();
            }
            if (!output.contains(content))
            {
                fail("Output '" + output + "' does not contain '" + content + "'");
            }
        }
    }

    /**
     * Helper method retrieving the next command published via the event manager.
     *
     * @return next event.
     */
    private Event assertEvent()
    {
        Event e = null;

        try
        {
            e = events.poll(30, TimeUnit.SECONDS);
        }
        catch (InterruptedException e1)
        {
            e1.printStackTrace();
            fail();
        }

        assertNotNull(e);
        return e;
    }

    private void assertCommandCommenced(String name)
    {
        Event e = assertEvent();
        assertTrue(e instanceof CommandCommencedEvent);

        CommandCommencedEvent ce = (CommandCommencedEvent) e;
        assertEquals(name, ce.getName());
    }

    private CommandCompletedEvent assertCommandCompleted(String commandName)
    {
        Event e = assertEvent();
        assertTrue(e instanceof CommandCompletedEvent);

        CommandCompletedEvent ce = (CommandCompletedEvent) e;
        assertEquals(commandName, ce.getResult().getCommandName());
        return ce;
    }

    protected File getCommandOutput(CommandResult commandResult) throws IOException
    {
        return getCommandArtifact(commandResult, commandResult.getArtifact(Command.OUTPUT_ARTIFACT_NAME));
    }

    protected File getCommandEnv(CommandResult commandResult) throws IOException
    {
        return getCommandArtifact(commandResult, commandResult.getArtifact(ExecutableCommand.ENV_ARTIFACT_NAME));
    }

    protected File getCommandArtifact(CommandResult result, StoredFileArtifact fileArtifact)
    {
        String commandDirName = String.format("00000000-%s", result.getCommandName());
        return new File(outputDir, FileSystemUtils.composeFilename(commandDirName, fileArtifact.getPath()));
    }

    protected File getCommandArtifact(CommandResult result, StoredArtifact artifact)
    {
        String commandDirName = String.format("00000000-%s", result.getCommandName());
        return new File(outputDir, FileSystemUtils.composeFilename(commandDirName, artifact.getFile().getPath()));
    }

    public void handleEvent(Event evt)
    {
        events.add(evt);
    }

    public Class[] getHandledEvents()
    {
        return new Class[]{Event.class};
    }
}
