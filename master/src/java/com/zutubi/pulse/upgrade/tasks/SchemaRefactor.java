package com.zutubi.pulse.upgrade.tasks;

import com.zutubi.pulse.util.JDBCUtils;
import org.hibernate.cfg.Environment;
import org.hibernate.connection.ConnectionProvider;
import org.hibernate.connection.ConnectionProviderFactory;
import org.hibernate.dialect.Dialect;
import org.hibernate.mapping.Column;
import org.hibernate.mapping.ForeignKey;
import org.hibernate.mapping.Table;
import org.hibernate.tool.hbm2ddl.DatabaseMetadata;
import org.hibernate.tool.hbm2ddl.SchemaUpdate;
import org.hibernate.tool.hbm2ddl.TableMetadata;

import java.sql.Connection;
import java.sql.SQLException;
import java.util.Iterator;
import java.util.List;
import java.util.Properties;

/**
 *
 *
 */
public class SchemaRefactor
{
    private MutableConfiguration config = null;
    private Dialect dialect = null;
    private Properties connectionProperties;
    private String defaultCatalog;
    private String defaultSchema;

    private List<Exception> exceptions;

    public SchemaRefactor(MutableConfiguration config, Properties props)
    {
        this.config = config;
        dialect = Dialect.getDialect(props);

        connectionProperties = new Properties();
        connectionProperties.putAll(dialect.getDefaultProperties());
        connectionProperties.putAll(props);

        defaultCatalog = config.getProperty(Environment.DEFAULT_CATALOG);
        defaultSchema = config.getProperty(Environment.DEFAULT_SCHEMA);
    }

    public void sync()
    {
        SchemaUpdate schemaUpdate = new SchemaUpdate(config, connectionProperties);
        schemaUpdate.execute(true, true);
        exceptions = schemaUpdate.getExceptions();
    }

    public String[] generateSyncSql() throws SQLException
    {
        return (String[]) executeWithConnection(new Callback()
        {
            public Object execute(Connection con) throws SQLException
            {
                DatabaseMetadata meta = new DatabaseMetadata(con, dialect);
                return config.generateSchemaUpdateScript(dialect, meta);
            }
        });
    }

    /**
     * currently only supported by the sync method.
     *
     * @return the list of exceptions generated by the sync command.
     */
    public List<Exception> getExceptions()
    {
        return exceptions;
    }

    public void renameTable(final String fromTableName, final String toTableName) throws SQLException
    {
        executeWithConnection(new Callback()
        {
            public Object execute(Connection con) throws SQLException
            {
                Table fromTable = getTable(fromTableName);

                // copy schema
                Table toTable = copyTable(con, fromTable, toTableName);

                // reassign fks.
                transferForeignKeys(con, fromTable, toTable);

                // drop original
                dropTable(con, fromTable);
                return null;
            }
        });
    }

    private void transferForeignKeys(Connection connection, Table fromTable, Table toTable) throws SQLException
    {
        DatabaseMetadata meta = new DatabaseMetadata(connection, dialect);

        Iterator i = config.getTableMappings();
        while (i.hasNext())
        {
            Table t = (Table) i.next();
            Iterator fki = t.getForeignKeyIterator();
            while (fki.hasNext())
            {
                ForeignKey fk = (ForeignKey) fki.next();
                Table referencedTable = fk.getReferencedTable();
                if (referencedTable != null && referencedTable == fromTable)
                {
                    TableMetadata tableInfo = meta.getTableMetadata(t.getName(), defaultSchema, defaultCatalog);

                    // verify that the fk is actually in the database.
                    if (tableInfo.getForeignKeyMetadata(fk.getName()) == null)
                    {
                        // foreign key does not exist, so do not drop or recreate it.
                        continue;
                    }

                    String sql = fk.sqlDropString(dialect, defaultCatalog, defaultSchema);
                    System.out.println(sql);
                    JDBCUtils.execute(connection, sql);
                    fk.setReferencedTable(toTable);

                    sql = fk.sqlCreateString(dialect, null, defaultCatalog, defaultSchema);
                    System.out.println(sql);
                    JDBCUtils.execute(connection, sql);
                }
            }
        }
    }

    private void conditionalBuildMappings()
    {
        if (!config.getTableMappings().hasNext())
        {
            config.buildMappings();
        }
    }

    public void renameColumn(final String tableName, final String fromColumnName, final String toColumnName) throws SQLException
    {
        executeWithConnection(new Callback()
        {
            public Object execute(Connection con) throws SQLException
            {
                Table table = getTable(tableName);
                Column column = getColumn(table, fromColumnName);
                renameColumn(con, table, column, toColumnName);
                return null;
            }
        });
    }

    public void dropSchema() throws SQLException
    {
        executeWithConnection(new Callback()
        {
            public Object execute(Connection con) throws SQLException
            {
                String[] sql = config.generateDropSchemaScript(dialect);
                for (String s : sql)
                {
                    System.out.println(s);
                }
                JDBCUtils.executeSchemaScript(con, sql);
                return null;
            }
        });
    }

    public void createSchema() throws SQLException
    {
        executeWithConnection(new Callback()
        {
            public Object execute(Connection con) throws SQLException
            {
                String[] sql = config.generateSchemaCreationScript(dialect);
                for (String s : sql)
                {
                    System.out.println(s);
                }
                JDBCUtils.executeSchemaScript(con, sql);
                return null;
            }
        });
    }

    private Column getColumn(Table table, String columnName)
    {
        Iterator columns = table.getColumnIterator();
        while (columns.hasNext())
        {
            Column column = (Column) columns.next();
            if (column.getName().equals(columnName))
            {
                return column;
            }
        }
        return null;
    }

    private void renameColumn(Connection connection, Table table, Column fromColumn, String toColumnName) throws SQLException
    {
        DatabaseMetadata meta = new DatabaseMetadata(connection, dialect);
        TableMetadata tableInfo = meta.getTableMetadata(table.getName(), defaultSchema, defaultCatalog);

        // a) identify foreign key references.
        ForeignKey columnKey = null;
        Iterator fks = table.getForeignKeyIterator();
        while (fks.hasNext())
        {
            ForeignKey fk = (ForeignKey) fks.next();
            if (fk.getColumns().contains(fromColumn))
            {
                columnKey = fk;
                String sql = fk.sqlDropString(dialect, defaultCatalog, defaultSchema);
                System.out.println(sql);
                JDBCUtils.execute(connection, sql);
            }
        }

        // update table model.
        String fromColumnName = fromColumn.getName();
        fromColumn.setName(toColumnName);

        Iterator alterSqls = table.sqlAlterStrings(dialect, config.getMapping(), tableInfo, defaultCatalog, defaultSchema);
        while (alterSqls.hasNext())
        {
            String sql = (String) alterSqls.next();
            System.out.println(sql);
            JDBCUtils.execute(connection, sql);
        }

        // copy column data.
        String sql = "update " + table.getName() + " set " + toColumnName + " = " + fromColumnName;
        System.out.println(sql);
        JDBCUtils.execute(connection, sql);

        if (columnKey != null)
        {
            sql = columnKey.sqlCreateString(dialect, config.getMapping(), defaultCatalog, defaultSchema);
            System.out.println(sql);
            JDBCUtils.execute(connection, sql);
        }

        // d) drop the column.
        sql = "alter table " + table.getName() + " drop column " + fromColumnName;
        System.out.println(sql);
        JDBCUtils.execute(connection, sql);
    }

    protected Table copyTable(Connection connection, Table fromTable, String toTableName) throws SQLException
    {
        config.buildMappings();

        Table toTable = clone(fromTable);
        toTable.setName(toTableName);

        String sql = toTable.sqlCreateString(dialect, null, defaultCatalog, defaultSchema);
        System.out.println(sql);
        JDBCUtils.execute(connection, sql);

        // if there is data to transfer..
        if (JDBCUtils.executeCount(connection, "select * from " + fromTable.getName()) > 0)
        {
            String columnSql = "";
            String sep = "";
            Iterator columns = toTable.getColumnIterator();
            while (columns.hasNext())
            {
                Column column = (Column) columns.next();
                columnSql = columnSql + sep + column.getName();
                sep = ",";
            }

            sql = "insert into " + toTableName + "(" + columnSql + ") select " + columnSql + " from " + fromTable.getName();
            System.out.println(sql);
            JDBCUtils.execute(connection, sql);
        }

        config.addTable(toTable);
        return toTable;
    }

    protected Table clone(Table table)
    {
        Table clone = new Table(table.getName());
        clone.setAbstract(table.isAbstract());
        clone.setCatalog(table.getCatalog());
        clone.setComment(table.getComment());
        clone.setName(table.getName());
        clone.setPrimaryKey(table.getPrimaryKey());
        clone.setQuoted(table.isQuoted());
        clone.setRowId(table.getRowId());
        clone.setSchema(table.getSchema());
        clone.setSubselect(table.getSubselect());

        Iterator columns = table.getColumnIterator();
        while (columns.hasNext())
        {
            Column column = (Column) columns.next();
            clone.addColumn(column);
        }

        return clone;
    }

    protected void dropTable(Connection connection, Table table) throws SQLException
    {
        String sql = table.sqlDropString(dialect, defaultCatalog, defaultSchema);
        System.out.println(sql);
        JDBCUtils.execute(connection, sql);
        config.removeTable(table);
    }

    protected Table getTable(String tableName)
    {
        Iterator tableMappings = config.getTableMappings();
        while (tableMappings.hasNext())
        {
            Table table = (Table) tableMappings.next();
            if (table.getName().equals(tableName))
            {
                return table;
            }
        }
        return null;
    }

    protected Object executeWithConnection(Callback c) throws SQLException
    {
        ConnectionProvider connectionProvider = null;
        Connection connection = null;
        try
        {
            connectionProvider = ConnectionProviderFactory.newConnectionProvider(connectionProperties);
            connection = connectionProvider.getConnection();

            conditionalBuildMappings();
            
            return c.execute(connection);
        }
        finally
        {
            JDBCUtils.close(connection);
            if (connectionProvider != null)
            {
                connectionProvider.close();
            }
        }
    }

    protected interface Callback
    {
        Object execute(Connection con) throws SQLException;
    }
}
