package com.zutubi.events;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.ThreadFactory;
import java.util.concurrent.TimeUnit;
import java.util.logging.Level;
import java.util.logging.Logger;

/**
 * An event listener that wraps another listener, passing events to that listener on via an
 * {@link ExecutorService}.  This effectively makes {@link #handleEvent(Event)} asynchronous.
 * <p/>
 * The use of this delegating listener ensures that events do not block the event dispatch thread.
 * If this listener uses a single-threaded executor service, events are also guaranteed to be
 * handled in the order they were sent.
 */
public class AsynchronousDelegatingListener implements EventListener
{
    private static final Logger LOG = Logger.getLogger(AsynchronousDelegatingListener.class.getName());

    private final EventListener delegate;
    private final String name;
    private final ExecutorService executor;

    /**
     * Wraps the given listener with event dispatch via the given executor.
     *
     * @param delegate the listener to wrap, events are forwarded to it asynchronously
     * @param name a descriptive name for this listener, used in logging
     * @param executor service used to call the wrapped listener
     */
    public AsynchronousDelegatingListener(EventListener delegate, String name, ExecutorService executor)
    {
        this.delegate = delegate;
        this.name = name;
        this.executor = executor;
    }

    /**
     * Wraps the given listener with event dispatch via a single-threaded executor.
     *
     * @param delegate the listener to wrap, events are forwarded asycnhronously
     * @param name a descriptive name for this listener, used to name the listener thread and in
     *             logging
     * @param threadFactory factory used to create the executor services' thread
     */
    public AsynchronousDelegatingListener(EventListener delegate, final String name, final ThreadFactory threadFactory)
    {
        this(delegate, name, Executors.newSingleThreadExecutor(new ThreadFactory()
        {
            public Thread newThread(Runnable runnable)
            {
                Thread thread = threadFactory.newThread(runnable);
                thread.setName(name);
                return thread;
            }
        }));
    }

    public void handleEvent(final Event event)
    {
        if (!executor.isShutdown())
        {
            executor.submit(new Runnable()
            {
                public void run()
                {
                    try
                    {
                        delegate.handleEvent(event);
                    }
                    catch (Exception e)
                    {
                        // isolate the exceptions generated by the event handling.
                        event.addException(e);
                        LOG.log(Level.WARNING, "Exception generated by handleEvent(" + event + ") of '" + name + "'", e);
                    }
                }
            });
        }
    }

    public Class[] getHandledEvents()
    {
        return delegate.getHandledEvents();
    }

    /**
     * Stops the underlying executor service, so that events will no longer be processed.  Waits for
     * shutdown to complete, though eventually the wait will time out.
     *
     * @param force true to force stop as soon as possible (discarding submitted events where
     *              possible), false to allow already-queued events to be processed
     */
    public void stop(boolean force)
    {
        if (force)
        {
            executor.shutdownNow();
        }
        else
        {
            executor.shutdown();
            try
            {
                if (!executor.awaitTermination(600, TimeUnit.SECONDS))
                {
                    LOG.warning("Time out awaiting termination of asynchronous listener for '" + name + "'");
                }
            }
            catch (InterruptedException e)
            {
                LOG.log(Level.WARNING, e.getMessage(), e);
            }
        }
    }
}
